# **지연로딩과 즉시로딩의 차이**

  **Fetch Type**은 연관 관계에 있는 엔티티를 언제 로드할지 결정하는 설정입니다.

  | **구분** | **지연 로딩 (Lazy)** | **즉시 로딩 (Eager)** |
      | --- | --- | --- |
  | **로드 시점** | 연관 엔티티의 필드를 **실제 사용할 때** (프록시 객체 초기화 시) | 엔티티를 **조회하는 즉시** (JOIN 쿼리 사용) |
  | **동작 원리** | 실제 엔티티 대신 **프록시 객체**를 채워 넣음. | 초기 조회 쿼리에 **JOIN**을 추가하여 한 번에 가져옴. |
  | **기본값** | `@OneToMany`, `@ManyToMany` | `@OneToOne`, `@ManyToOne` |
  | **권장** | **권장** (N+1 문제 방지 및 성능 최적화 유리) | **비권장** (N+1 문제 발생 가능성이 높음) |

# **JPQL**
- **정의:** JPA에서 제공하는 **객체지향 쿼리 언어**입니다. SQL을 추상화하여 특정 데이터베이스에 의존하지 않고 엔티티 객체를 대상으로 쿼리를 작성할 수 있게 합니다.
- **특징:** SQL과 비슷하지만, **테이블이 아닌 엔티티 객체와 필드를 대상**으로 쿼리를 작성합니다.
- **용도:** 특정 조건의 엔티티를 조회하거나, 대량의 데이터에 대한 벌크(Bulk) 연산(Update, Delete)을 수행할 때 사용됩니다.

# **Fetch Join**
- **정의:** JPQL 문법의 한 종류로, **JOIN**을 사용하면서 동시에 연관 엔티티를 **즉시 로딩**으로 가져오는 기능입니다.
- **사용 목적:** 지연 로딩(Lazy)으로 설정된 연관 엔티티를 특정 조회 시점에 **N+1 문제없이** 한 번의 쿼리로 함께 가져오기 위해 사용됩니다.
- **문법:** `SELECT m FROM Member m JOIN FETCH m.team`
- **효과:** 연관 엔티티가 영속성 컨텍스트에 채워져 지연 로딩 시 발생할 수 있는 추가 쿼리나 프록시 초기화 문제를 방지합니다.

# **@EntityGraph**
- **정의:** JPA에서 제공하는 기능으로, 엔티티를 조회할 때 **함께 가져올 연관 엔티티**를 명시적으로 지정하는 메커니즘입니다.
- **사용 목적:** 기본적으로 지연 로딩(Lazy)을 유지하면서, **특정 조회 메서드**에서만 필요한 연관 엔티티를 **Fetch Join과 유사하게** 한 번의 쿼리로 가져오게 합니다.
- **설정:** 엔티티에 `@NamedEntityGraph`로 그래프를 정의하고, 레파지토리 메서드에 `@EntityGraph` 어노테이션을 붙여 사용합니다.
- **장점:** JPQL에 직접 `FETCH JOIN`을 사용하지 않고, 메타데이터 방식으로 로딩 전략을 유연하게 변경할 수 있습니다.

# **commit과 flush 차이점**
| **구분** | **flush** | **commit** |
| --- | --- | --- |
| **정의** | 영속성 컨텍스트의 변경 내용 (쓰기 지연 SQL 저장소)을 DB에 **동기화**하는 작업. | DB에 변경된 내용을 **최종 반영**하고 트랜잭션을 **완료**하는 작업. |
| **SQL 전송** | 생성된 SQL이 DB에 **전송**됩니다. | 트랜잭션 종료 시 **DB에 최종 반영**됩니다. |
| **트랜잭션** | 트랜잭션은 **유지**됩니다. | 트랜잭션을 **종료**합니다. |
| **발생 시점** | JPQL 실행 전, 특정 API 호출 시 (`em.flush()`), 트랜잭션 커밋 직전. | 트랜잭션이 성공적으로 완료될 때. |

# **QueryDSL, OpenFeign의 QueryDSL**
  ### QueryDSL
  - **정의:** **JPQL을 코드로 작성**할 수 있도록 도와주는 **타입-세이프(Type-Safe)** 쿼리 빌더 프레임워크입니다.
  - **특징:**
  - **컴파일 시점 오류 감지:** 문자열 기반의 JPQL과 달리, 자바 코드로 쿼리를 작성하므로 오타 등의 오류를 컴파일 시점에서 잡을 수 있습니다.
  - **동적 쿼리:** 조건에 따라 쿼리 내용이 유동적으로 바뀌는 동적 쿼리 작성이 매우 편리합니다.
  - **사용:** 주로 엔티티를 기반으로 생성되는 **Q-Type** 클래스를 사용하여 쿼리를 구성합니다.

  ### OpenFeign의 QueryDSL (비표준/커스텀)
  - **배경:** **OpenFeign**은 REST API 클라이언트를 쉽게 생성해주는 라이브러리입니다. OpenFeign 자체는 QueryDSL과 직접적인 연관이 없습니다.
  - **실제 의미:** 일반적으로 MSA 환경에서 **OpenFeign을 사용하여 외부 API를 호출**할 때, 요청 파라미터를 **QueryDSL의 문법/방식**과 유사하게 동적으로 구성하여 HTTP GET 요청의 쿼리 파라미터로 전달하는 **커스텀 구현 패턴**을 의미할 수 있습니다.
  - **결론:** QueryDSL은 **DB 쿼리**를 위해, OpenFeign은 **HTTP 통신**을 위해 사용되며, 두 기술을 연동하는 것은 개발자가 필요에 따라 구현하는 패턴입니다.

# **N+1 문제 해결할 수 있는 여러 방안들**

  **N+1 문제**는 1번의 쿼리로 N개의 엔티티를 가져온 후, 각 엔티티에 대한 연관 엔티티를 로드하기 위해 N번의 추가 쿼리가 발생하는 비효율적인 상황을 말합니다.

  | **해결 방안** | **설명** | **장점** |
      | --- | --- | --- |
  | **1. Fetch Join** | JPQL에서 `JOIN FETCH`를 사용하여 연관 엔티티를 **한 번의 쿼리**로 함께 가져옵니다. | 가장 직접적이고 성능이 좋습니다. |
  | **2. @EntityGraph** | `@EntityGraph`를 사용하여 특정 메서드에서만 원하는 연관 엔티티를 **JOIN**으로 가져오도록 설정합니다. | 코드의 유연성이 높고 로딩 전략을 분리할 수 있습니다. |
  | **3. Batch Size 설정** | `hibernate.default_batch_fetch_size` 또는 `@BatchSize`를 설정하여, N개의 쿼리를 **IN 절**을 사용하는 소수의 쿼리로 **묶어서** 실행합니다. | 설정만으로 광범위하게 적용 가능하며, N+1을 1 + N/M 형태로 개선합니다. |
  | **4. 지연 로딩 유지** | 연관 엔티티가 **정말로 필요하지 않다면** 기본적으로 지연 로딩을 유지하고 사용하지 않습니다. | 불필요한 데이터를 아예 조회하지 않습니다. |

# **영속 상태의 종류**

  JPA 엔티티의 상태는 영속성 컨텍스트(Persistence Context)를 기준으로 네 가지 생명주기를 가집니다.
  1. **비영속 (New/Transient)**
     - 엔티티 객체를 **생성만 한 상태**로, 영속성 컨텍스트나 DB와 전혀 관계가 없습니다.
     - **예시:** `Member member = new Member();`
  2. **영속 (Managed/Persistent)**
     - 엔티티가 **영속성 컨텍스트에 저장**되어 관리되는 상태입니다.
     - **특징:** 이 상태의 엔티티는 변경되면 **자동으로 감지(Dirty Checking)**되어 DB에 반영됩니다.
     - **예시:** `em.persist(member);` 또는 `em.find(Member.class, id);`로 조회된 상태.
  3. **준영속 (Detached)**
     - 영속성 컨텍스트에 **저장되었다가 분리된 상태**입니다. 더 이상 영속성 컨텍스트가 관리하지 않으므로 변경해도 DB에 자동 반영되지 않습니다.
     - **예시:** `em.detach(member);`, `em.clear();`, `em.close();`
  4. **삭제 (Removed)**
     - 엔티티가 영속성 컨텍스트에서 삭제되었고, 트랜잭션 커밋 시 **DB에서도 삭제**될 준비가 된 상태입니다.
     - **예시:** `em.remove(member);`